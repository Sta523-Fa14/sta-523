---
title: 'Project 4'
output: html_document
---

###is_valid = function(g)

This function is used to check whether the graph object is valid or not which means it needs to match many criteria. Thus, we need to check each vertex, edge and corresponding weight. At first we use for loop and if else statement to fulfill my goal rather than “sapply” because we think it is easier to code and a little more readable. Thus, we use for loop to check each list in the graph object to make sure it match all criteria. This time, we learnt a lot logical operation function in r and get more familiar with list object in r.


###is_undirected = function(g)
  
In this function, g refers to the graph object. We intend to check whether the graph is directed or undirected. Basically in a graph, when the weights on the edges between any two vertices are same in both the directions, then that graph is considered undirected. To test these cases, we created an Adjacency matrix to recreate the graph object, which is in the form of lists. After that we check whether the weights between edges are same (say Matrix[i,j] value should be equal to Matrix [j,i] value). When this test condition fails for at least one case, we return the value FALSE, else the graph is undirected and we return the value TRUE.


###is_isomorphic = function(g1, g2)

In this function, the first thing we do is to check whether the given input graphs are valid using the is_valid function. There is no need to proceed the function if the graphs are not valid in the first place. The next thing is to check whether all vertices are identical by calling the names function since comparison of vertices are based on names. The function will return false if vertices are different. If they are identical, then the function proceeds to the next step, which is to compare edges and weights. We iterate through the index of either g1 or g2(up to this point they should have the same length) using a for loop. g1[[i]]$edges gives the vertices that the ith vertex points to in integers, then we use the integers as index to find the corresponding names of the vertices and store them in v1. g1[[i]]$weights returns the weights of those edges and we store them in w1. Using the match function, we find the index of the ith vertex of g1 in g2 based on names, then use the same logic to obtain the edges and weights and store them in v2 and w2. The final task is to check whether all edges and weights are equal. If any of the v1,v2,w1,w2 is empty, then they should all be empty, otherwise the function returns false. Since v1,v2,w1,w2 may be vectors, we can compare them by using %in%, if either of the two pairs is different, the function returns false. Finally, if everything is identical, the function returns true.


###is_connected = function(g, v1, v2)

In this function, the input "g" is a graph object, and "v1" and "v2" are two vertex labels in "g". We expect the function to return "TRUE" if if there is a path from "v1"" to "v2" in "g", and false if not. First, if "g" is not a list, which means that "g" is "bad graph", the function throws an error. Then, if "g" is not valid given our function "is_valid", i.e., "g" is "1", "TRUE", which also means that "g" is "bad graph", the function throws an error. Third, if "v1" or "v2" dosn't match any names or indexes in the list of "g" (i.e., "A","B", or "1","2"), such as when vertex input is "TRUE", "NaN", or when it's "C" while none of the names in "g" is "C", or when it's "3" while there is only 2 sub-lists in "g", the function throws an error. Then, if the edges corresponds to "v1" is empty, the function returns "FALSE", which means that there's no path from "v1"" to "v2". Otherwise, we use "path" to record the edges corresponds to "v1". If "v1" is a character like "A" or "B", we first turn "v1" into the corresponding index in "g". We know that now "path" records all vertices connected directly with "v1", and maybe there are more vertices connected undirectly with "v1", so we continue to add edges elemnts to "path", by finding all edges corresponds to the elements in "path". Also, we use "name" to record all the name labels in "g" corresponds to elements in "path". So whether "v2" is charater like "A", or index like "1", we now can compare the "path" and "name" with "v2". If "path" or "name" has element that is the same with "v2", then the function retunrs "TRUE", which means that we conclude "v1" and "v2" are connected, directly or undirectly. Otherwise, the function returns "FALSE", which means that the two vertices are not connected. Note that we start with "v1", which makes sure that the dirction of connection is from "v1" to "v2".



###write_graph = function(g, file)

In this function, the input "g" is a graph object, and "file" is the file to write to. This function is used to wirte graph (vertices, edges, and weights) to the given file according to the file format specification. First, if "g" is not invalid graph, or if "file"" already exists, or if directory of "file" doesn't exist, the function throws an error. Then we set "txt" and "weights" as null objects, where "txt" is used to record ALL the contents to write into the "file", and "weights" is used to record the weights element everytime, if weights exists. We use "from" to record the vertex where the connection starts by catching the names in "g", one by one. Note that if there is space in "from", like when "from" is "A A", we add quotations to "from" to keep it consistent with the names in "g". Otherwise we just leave "from" as what we catched. Then, if the edges corresponds to this vertex is empty, which means that there's no connection from this vertex to any other vertices, we just use "txt" to paste what we have recorded in "txt", "from", a semicolon, and "\n", with no space among these elements. "\n" ensures that when we write the contents in "txt" into a file, the contents before "\n" and after "\n" will be in seperate lines. An example to illustrate what's added in "txt" this time is "A;". Now we repeat what we've done to "from", and this time if the edges corresponds to this vertex is not empty, which means that there's connection from this vertex to one or more vertices, we use "to" to record every vertex where the connection is directed to, by catching the names in "g" corresponds to each element in edges of "from", one by one. Similarly, if there is space in "to", like when "to" is "B B", we add quotations to "to" to keep it consistent with the names in "g". Otherwise we just leave "to" as what we catched. Then we use "txt" to paste what we have recorded in "txt" and "from", with no space between them, and add "->" and "to" to "txt", with space among them. If the weights corresponds to "from" is empty, we use "txt" to paste what we have recorded in "txt", a semicolon, and "\n", with no space among these elements. An example to illustrate what's added in "txt" this time is "A -> B;". If the weights corresponds to "from" is not empty, we use "weights" to paste "[weight=", each weight element in the weights corresponds to "from", and "]", with no space among them. For example, weights="[weight=14]". Then we use "txt" to paste what we have recorded in "txt" and "weights", with space between them, and add a semicolon and "\n" to "txt", with no space among these elements. An example to illustrate what's added in "txt" this time is ""A A" -> "C C" [weight=1];". After we have recorded all elements in "g", we write the contents in "txt" to the "file".


###read_graph = function(file)

This function uses package stringr. The first thing is to check whether the input file exists. If not, the function terminates immediately. Then we check if the file violates the specified format by using the string match function. If the graph doesn't match any of the patterns that we put as argument for the string match function, then it is a bad file and the function return a list of length zero. We throw an error when this happens. If the file is in good format, then we read it into R as a matrix, and use string replace funcion to get rid of the semicolons, square brackets and "weights=" that we don't need. We notice that if the file has all elements(vertices, edges and weights), the matrix should have four columns, vertices, arrows(->), edges and weights. But not all files are in this complete format, so we expand all matrices that have less than four columns to have four columns for convenience of later use. After the initial cleaning stage, we now start building the graph. The unique(sort(vertex[vertex!=""])) gives us all the vertices in the graph. Then we create a list g that contains all the vertices with empty edges and weights. We use a for loop to iterate through each row of the graph matrix. If the edge or weight is not empty for that row we store it in the list under the name of the vertex that this row corresponds to. A special case is when there is an edge but no weight is given, we assume that the weight is 1. After all iterations, we have contructed a complete graph object.


###shortest_path = function(g, v1, v2)

This function is used to find out the shortest path from one given vertex v1 to another given vertex v2 in a given graph object g. Inspired by professor’s has_loop example, we used a traverse function to return the shortest path and distance between a given vertex v and starting vertex v1. 
The idea of traverse vertex is to find out the vertices (u1, u2,…) have a path directly to v and calculate the shortest path and distance from v1 to v through u1, u2,… by using traverse function of u1, u2,… Thus, it is a recursive method. However, it would have nested problem and we put one more variable in the input of the function traverse, visited, which can avoid search the vertex has already been visited. 


###min_span_tree = function(g)
  
In this function, g refers to the graph object. We check whether this graph object is directed. Only if it is undirected this min_span_tree function will work. By taking g as input we wish to identify the path in the tree which covers all the vertices at minimum cost i.e. minimum sum of the weights of edges considered in the path. We implemented the famous Prim's algorithm to identify the minimum spanning tree (MST). The identified MST comes in the form of a matrix. However, since the homework question expects us to return an undirected graph object, we convert the adjacency matrix of the undirected MST into a graph and returned it. 


###plotting

As to plotting, we want to use physics method to find out the place of vertices should be on the surface. At first we uniformly randomize the vertices and then assume there is a spring between two vertices if there is an edge between these two vertices. Besides, the original length of the spring is the weight of the edge. After that, we set a small time period and small elastic coeffient so that if the vertices is too far or too close, the spring will pull or push them. We update the place of each vertex according to force principle. After a long enough period, the vertices will appear in the reasonable place.